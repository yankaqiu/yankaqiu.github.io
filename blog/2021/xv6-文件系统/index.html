<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> xv6 文件系统手册和代码阅读笔记 | Jing Yan </title> <meta name="author" content="Jing Yan"> <meta name="description" content=""> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9C%85&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yankaqiu.github.io/blog/2021/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Jing</span> Yan </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/assets/pdf/Resume_Jing_Yan.pdf">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">xv6 文件系统手册和代码阅读笔记</h1> <p class="post-meta"> Created in August 17, 2021 </p> <p class="post-tags"> <a href="/blog/2021"> <i class="fa-solid fa-calendar fa-sm"></i> 2021 </a>   ·   <a href="/blog/tag/os"> <i class="fa-solid fa-hashtag fa-sm"></i> os</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <h1 id="xv6-文件系统手册和代码阅读笔记">xv6 文件系统手册和代码阅读笔记</h1> <h2 id="一手册阅读">一、手册阅读</h2> <p>分为六层实现，</p> <p><img src="https://th0ar.gitbooks.io/xv6-chinese/content/pic/f6-1.png" alt="figure6-1"></p> <p>最下面一层通过块缓冲读写IDE盘，同步了对磁盘的访问，保证同时只有一个内核进程可以修改磁盘块。第二层使得更高层的接口可以将对磁盘的更新按会话打包，通过会话的方式来保证这些操作是原子操作（要么都被应用，要么都不被应用）。第三层提供无名文件，每一个这样的文件由一个 i node 和一连串的数据块组成。第四层将目录实现为一种特殊的 i node，它的内容是一连串的目录项，每一个目录项包含一个文件名和对应的 i node。第五层提供了层次路经名，这一层通过递归的方式来查询路径对应的文件。最后一层将许多 UNIX 的资源（如管道，设备，文件等）抽象为文件系统的接口。</p> <h3 id="块缓冲层">块缓冲层</h3> <p>两个任务：（1）同步对磁盘的访问，使得对于每一个块，同一时间只有一份拷贝放在内存中并且只有一个内核线程使用这份拷贝；（2）缓存常用的块以提升性能。</p> <p>块缓冲提供的的主要接口是 <code class="language-plaintext highlighter-rouge">bread</code> 和 <code class="language-plaintext highlighter-rouge">bwrite</code>；前者从磁盘中取出一块放入缓冲区，后者把缓冲区中的一块写到磁盘上正确的地方。当内核处理完一个缓冲块之后，需要调用 <code class="language-plaintext highlighter-rouge">brelse</code> 释放它。</p> <p>块缓冲仅允许最多一个内核线程引用它，以此来同步对磁盘的访问，如果一个内核线程引用了一个缓冲块，但还没有释放它，那么其他调用 <code class="language-plaintext highlighter-rouge">bread</code> 的进程就会阻塞。文件系统的更高几层正是依赖块缓冲层的同步机制来保证其正确性。</p> <p>块缓冲有固定数量的缓冲区，这意味着如果文件系统请求一个不在缓冲中的块，必须换出一个已经使用的缓冲区。置换策略使用的是 LRU。</p> <h3 id="日志层">日志层</h3> <p>日志设计</p> <p>xv6 通过简单的日志系统来解决文件操作过程当中崩溃所导致的问题。一个系统调用并不直接导致对磁盘上文件系统的写操作，相反，他会把一个对磁盘写操作的描述包装成一个日志写在磁盘中。当系统调用把所有的写操作都写入了日志，它就会写一个特殊的提交记录到磁盘上，代表一次完整的操作。从那时起，系统调用就会把日志中的数据写入磁盘文件系统的数据结构中。在那些写操作都成功完成后，系统调用就会删除磁盘上的日志文件。</p> <p>对日志的常见使用方法像下面这样</p> <pre><code class="language-C">begin_trans();
...
bp = bread(...);
bp-&gt;data[...] = ...;
log_write(bp);
...
commit_trans();
</code></pre> <p><code class="language-plaintext highlighter-rouge">begin_trans</code> 会一直等到它独占了日志的使用权后返回。</p> <p><code class="language-plaintext highlighter-rouge">log_write</code>像是 <code class="language-plaintext highlighter-rouge">bwrite</code> 的一个代理；它把块中新的内容记录到日志中，并且把块的扇区号记录在内存中。<code class="language-plaintext highlighter-rouge">log_write</code> 仍将修改后的块留在内存中的缓冲区中，因此相继的本会话中对这一块的读操作都会返回已修改的内容。<code class="language-plaintext highlighter-rouge">log_write</code> 能够知道在一次会话中对同一块进行了多次读写，并且覆盖之前同一块的日志。</p> <p><code class="language-plaintext highlighter-rouge">commit_trans</code> 将日志的起始块写到磁盘上，这样在这个时间点之后的系统崩溃就能够恢复，只需将磁盘中的内容用日志中的内容改写。<code class="language-plaintext highlighter-rouge">commit_trans</code> 调用 <code class="language-plaintext highlighter-rouge">install_trans</code>（4221） 来从日志中逐块的读并把他们写到文件系统中合适的地方。最后 <code class="language-plaintext highlighter-rouge">commit_trans</code> 会把日志起始块中的计数改为0，这样在下次会话之前的系统崩溃就会使得恢复代码忽略日志。</p> <p><code class="language-plaintext highlighter-rouge">recover_from_log</code> 在 <code class="language-plaintext highlighter-rouge">initlog</code> 中被调用，而 <code class="language-plaintext highlighter-rouge">initlog</code> 在第一个用户进程开始前的引导过程中被调用。它读取日志的起始块，如果起始块说日志中有一个提交了的会话，它就会仿照 <code class="language-plaintext highlighter-rouge">commit_trans</code> 的行为执行，从而从错误中恢复。</p> <p><code class="language-plaintext highlighter-rouge">filewrite</code> 中有一个使用了日志的例子：</p> <pre><code class="language-C">begin_trans();
ilock(f-&gt;ip);
r = writei(f-&gt;ip, ...);
iunlock(f-&gt;ip);
commit_trans();
</code></pre> <p>在一个用于将一次大的写操作拆分成一些会话的循环中找到了这段代码，在每一次会话中这段只会写部分块，因为日志的大小是有限固定的。对 <code class="language-plaintext highlighter-rouge">writei</code> 的调用会在一次会话中写很多的块：文件的 i 节点，一个或多个位图块，以及一些数据块。在 <code class="language-plaintext highlighter-rouge">begin_trans</code> 之后再执行 <code class="language-plaintext highlighter-rouge">ilock</code> 是一种避免死锁的办法：因为每次会话都已经有一个锁保护了，因此在持有两个锁的时候，要保证一定的加锁顺序。</p> <h3 id="i-node">i node</h3> <p><em>i 节点</em>这个术语可以有两个意思。它可以指的是磁盘上的记录文件大小、数据块扇区号的数据结构。也可以指内存中的一个 i 节点，它包含了一个磁盘上 i 节点的拷贝，以及一些内核需要的附加信息。</p> <p>所有的磁盘上的 i 节点都被打包在一个称为 i 节点块的连续区域中。每一个 i 节点的大小都是一样的，所以对于一个给定的数字n，很容易找到磁盘上对应的 i 节点。事实上这个给定的数字就是操作系统中 i 节点的编号。</p> <p>磁盘上的 i 节点由结构体 <code class="language-plaintext highlighter-rouge">dinode</code>定义。<code class="language-plaintext highlighter-rouge">type</code> 域用来区分文件、目录和特殊文件的 i 节点。如果 <code class="language-plaintext highlighter-rouge">type</code> 是0的话就意味着这是一个空闲的 i 节点。<code class="language-plaintext highlighter-rouge">nlink</code> 域用来记录指向了这一个 i 节点的目录项，这是用于判断一个 i 节点是否应该被释放的。<code class="language-plaintext highlighter-rouge">size</code> 域记录了文件的字节数。<code class="language-plaintext highlighter-rouge">addrs</code> 数组用于这个文件的数据块的块号。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// On-disk inode structure</span>
<span class="k">struct</span> <span class="n">dinode</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>           <span class="c1">// File type, files, directories, or special files (devices)</span>
                        <span class="c1">// 0 indicates dinode is free</span>
  <span class="kt">short</span> <span class="n">major</span><span class="p">;</span>          <span class="c1">// Major device number (T_DEVICE only)</span>
  <span class="kt">short</span> <span class="n">minor</span><span class="p">;</span>          <span class="c1">// Minor device number (T_DEVICE only)</span>
  <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span>          <span class="c1">// Number of links to inode in file system</span>
                        <span class="c1">// won’t free an inode if its link count is greater than 0</span>
                        <span class="c1">// 统计指向这个inode的目录条目（硬链接数）</span>
                        <span class="c1">// 用于指示何时磁盘上的inode和它对应的data blocks应该被释放</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>            <span class="c1">// Size of file (bytes)</span>
                        <span class="c1">// the number of bytes of content in the file</span>
  <span class="n">uint</span> <span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// Data block addresses</span>
                           <span class="c1">// records the block numbers of the disk blocks holding the file’s content.</span>
  			   <span class="c1">// NDIRECT = 12, 12个直接块，第13个是一级间接块</span>
                           <span class="c1">// 默认大小为(12+256)*BISZE = 268KB</span>
<span class="p">}</span>
</code></pre></div></div> <p>内核在内存中维护活动的 i 节点。结构体 <code class="language-plaintext highlighter-rouge">inode</code>是磁盘中的结构体 <code class="language-plaintext highlighter-rouge">dinode</code> 在内存中的拷贝。内核只会在有 C 指针指向一个 i 节点的时候才会把这个 i 节点保存在内存中。<code class="language-plaintext highlighter-rouge">ref</code> 域用于统计有多少个 C 指针指向它。如果 <code class="language-plaintext highlighter-rouge">ref</code> 变为0，内核就会丢掉这个 i 节点。<code class="language-plaintext highlighter-rouge">iget</code> 和 <code class="language-plaintext highlighter-rouge">iput</code> 两个函数申请和释放 i 节点指针，修改引用计数。i 节点指针可能从文件描述符产生，从当前工作目录产生，也有可能从一些内核代码如 <code class="language-plaintext highlighter-rouge">exec</code> 中产生。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in-memory copy of an inode(struct dinode)</span>
<span class="c1">// kernel stores an inode in memory only if there are C pointers referring to that inode</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">dev</span><span class="p">;</span>           <span class="c1">// Device number</span>
  <span class="n">uint</span> <span class="n">inum</span><span class="p">;</span>          <span class="c1">// Inode number</span>
  <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>            <span class="c1">// Reference count</span>
                      <span class="c1">// 在内存中指向该inode的指针数，注意区分和dinode的nlink</span>
                      <span class="c1">// ref大于0，就会继续在icache中保存该inode，而且该缓存条目不会被置换成别的inode</span>
                      <span class="c1">// ref为0时，内核就清除该inode在icache中的副本</span>
                      <span class="c1">// nlink是硬链接，断电之后还会保存在磁盘里面</span>
                      <span class="c1">// 而ref是内存里面的数据结构，断电之后就会消失</span>
  <span class="k">struct</span> <span class="n">sleeplock</span> <span class="n">lock</span><span class="p">;</span> <span class="c1">// protects everything below here</span>
                         <span class="c1">// ensures exclusive access to the inode’s fields as well as to the inode’s file or directory content blocks.</span>
  <span class="kt">int</span> <span class="n">valid</span><span class="p">;</span>          <span class="c1">// inode has been read from disk?</span>

  <span class="c1">//以下为struct dinode的成员</span>
  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>         <span class="c1">// copy of disk inode</span>
  <span class="kt">short</span> <span class="n">major</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">minor</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
</code></pre></div></div> <p>持有 <code class="language-plaintext highlighter-rouge">iget</code> 返回的 i 节点的指针将保证这个 i 节点会留在缓存中，不会被删掉（特别地不会被用于缓存另一个文件）。因此 <code class="language-plaintext highlighter-rouge">iget</code> 返回的指针相当一种较弱的锁，虽然它并不要求持有者真的锁上这个 i 节点。文件系统的许多部分都依赖于这个特性，一方面是为了长期地持有对 i 节点的引用（比如打开的文件和当前目录），一方面是在操纵多个 i 节点的程序中避免竞争和死锁（比如路径名查找）。</p> <p><code class="language-plaintext highlighter-rouge">iget</code> 返回 i 节点可能没有任何有用的内容。为了保证它持有一个磁盘上 i 节点的有效拷贝，程序必须调用<code class="language-plaintext highlighter-rouge">ilock</code>。它会锁住 i 节点（从而其他进程就无法使用它）并从磁盘中读出 i 节点的信息（如果它还没有被读出的话）。<code class="language-plaintext highlighter-rouge">iunlock</code> 释放 i 节点上的锁。把对i 节点指针的获取和 i 节点的锁分开避免了某些情况下的死锁，比如在目录查询的例子中，数个进程都可以通过 <code class="language-plaintext highlighter-rouge">iget</code> 获得一个 i 节点的 C 指针，只有一个进程可以锁住一个 i 节点。</p> <p>i 节点缓存只会缓存被 C 指针指向的 i 节点。它主要的工作是同步多个进程对 i 节点的访问而非缓存。如果一个 i 节点频繁被使用，块缓冲可能会把它保留在内存中，即使 i 节点缓存没有缓存它。</p> <h3 id="文件描述符层">文件描述符层</h3> <p>xv6 给每个进程都有一个自己的打开文件表，每一个打开文件都由结构体 <code class="language-plaintext highlighter-rouge">file</code>表示，它是一个对 i 节点或者管道和文件偏移的封装。每次调用 <code class="language-plaintext highlighter-rouge">open</code> 都会创建一个新的打开文件（一个新的 <code class="language-plaintext highlighter-rouge">file</code>结构体）。如果多个进程相互独立地打开了同一个文件，不同的实例将拥有不同的 i/o 偏移。另一方面，同一个文件可以（同一个file结构体）可以在一个进程的文件表中多次出现，同时也可以在多个进程的文件表中出现。当一个进程用 <code class="language-plaintext highlighter-rouge">open</code> 打开了一个文件而后使用 <code class="language-plaintext highlighter-rouge">dup</code>，或者把这个文件和子进程共享就会导致这一点发生。对每一个打开的文件都有一个引用计数，一个文件可以被打开用于读、写或者二者。<code class="language-plaintext highlighter-rouge">readable</code>域和<code class="language-plaintext highlighter-rouge">writable</code>域记录这一点。</p> <p>系统中所有的打开文件都存在于一个全局的文件表 <code class="language-plaintext highlighter-rouge">ftable</code> 中。这个文件表有一个分配文件的函数（<code class="language-plaintext highlighter-rouge">filealloc</code>），有一个重复引用文件的函数（<code class="language-plaintext highlighter-rouge">filedup</code>），释放对文件引用的函数（<code class="language-plaintext highlighter-rouge">fileclose</code>），读和写文件的函数（<code class="language-plaintext highlighter-rouge">fileread</code> 和 <code class="language-plaintext highlighter-rouge">filewrite</code> ）。</p> <p><code class="language-plaintext highlighter-rouge">Filealloc</code> 扫描整个文件表来寻找一个没有被引用的文件（<code class="language-plaintext highlighter-rouge">file-&gt;ref == 0</code>)并且返回一个新的引用；<code class="language-plaintext highlighter-rouge">filedup</code>增加引用计数；<code class="language-plaintext highlighter-rouge">fileclose</code>减少引用计数。当一个文件的引用计数变为0的时候，<code class="language-plaintext highlighter-rouge">fileclose</code>就会释放掉当前的管道或者i 节点（根据文件类型的不同）。</p> <p>函数<code class="language-plaintext highlighter-rouge">filestat</code>，<code class="language-plaintext highlighter-rouge">fileread</code>，<code class="language-plaintext highlighter-rouge">filewrite</code> 实现了对文件的 <code class="language-plaintext highlighter-rouge">stat</code>，<code class="language-plaintext highlighter-rouge">read</code>，<code class="language-plaintext highlighter-rouge">write</code> 操作。<code class="language-plaintext highlighter-rouge">filestat</code> (5302)只允许作用在 i 节点上，它通过调用 <code class="language-plaintext highlighter-rouge">stati</code> 实现。<code class="language-plaintext highlighter-rouge">fileread</code> 和 <code class="language-plaintext highlighter-rouge">filewrite</code> 检查这个操作被文件的打开属性所允许然后把执行让渡给 i 节点的实现或者管道的实现。如果这个文件代表的是一个 i 节点，<code class="language-plaintext highlighter-rouge">fileread</code>和 <code class="language-plaintext highlighter-rouge">filewrite</code> 就会把 i/o 偏移作为该操作的偏移并且往前移。管道没有偏移这个概念。回顾一下 i 节点的函数需要调用者来处理锁。i 节点锁有一个方便的副作用那就是读写偏移会自动更新，所以同时对一个文件写并不会覆盖各自的文件，但是写的顺序是不被保证的，因此写的结果可能是交织的（在一个写操作的过程中插入了另一个写操作）。</p> <h2 id="二代码阅读">二、代码阅读</h2> <p>文件系统部分 buf.h fcntl.h stat.h fs.h file.h ide.c bio.c log.c fs.c file.c sysfile.c exec.c</p> <p>1.buf.h：对xv6中磁盘块数据结构进行定义，块大小为512字节。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// xv6中磁盘块数据结构,块大小512字节</span>
<span class="k">struct</span> <span class="n">buf</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span> <span class="c1">// DIRTY, VALID</span>
  <span class="n">uint</span> <span class="n">dev</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">sector</span><span class="p">;</span> <span class="c1">// 对应扇区</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span> <span class="c1">// LRU cache list</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span> <span class="c1">// 链式结构用于连接</span>
  <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">qnext</span><span class="p">;</span> <span class="c1">// disk queue</span>
  <span class="n">uchar</span> <span class="n">data</span><span class="p">[</span><span class="mi">512</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define B_BUSY  0x1  // buffer is locked by some process
#define B_VALID 0x2  // buffer has been read from disk
#define B_DIRTY 0x4  // buffer needs to be written to disk
</span></code></pre></div></div> <p>2.fcntl.h：宏定义操作权限。</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#define O_RDONLY  0x000 // 只读</span>
<span class="c">#define O_WRONLY  0x001 // 只写</span>
<span class="c">#define O_RDWR    0x002 // 读写</span>
<span class="c">#define O_CREATE  0x200 // 创建</span>
</code></pre></div></div> <p>3.stat.h：声明文件或目录属性数据结构。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define T_DIR  1   // Directory
#define T_FILE 2   // File
#define T_DEV  3   // Device
</span>
<span class="k">struct</span> <span class="n">stat</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>  <span class="c1">// Type of file</span>
  <span class="kt">int</span> <span class="n">dev</span><span class="p">;</span>     <span class="c1">// File system's disk device</span>
  <span class="n">uint</span> <span class="n">ino</span><span class="p">;</span>    <span class="c1">// Inode number</span>
  <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span> <span class="c1">// Number of links to file</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>   <span class="c1">// Size of file in bytes</span>
<span class="p">};</span>
</code></pre></div></div> <p>4.fs.h / fs.c：声明超级块、dinode、文件和目录数据结构，以及相关的宏定义。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define ROOTINO 1  // root i-number
#define BSIZE 512  // block size
</span>
<span class="c1">// File system super block</span>
<span class="k">struct</span> <span class="n">superblock</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>         <span class="c1">// Size of file system image (blocks)</span>
  <span class="n">uint</span> <span class="n">nblocks</span><span class="p">;</span>      <span class="c1">// Number of data blocks</span>
  <span class="n">uint</span> <span class="n">ninodes</span><span class="p">;</span>      <span class="c1">// Number of inodes.</span>
  <span class="n">uint</span> <span class="n">nlog</span><span class="p">;</span>         <span class="c1">// Number of log blocks</span>
<span class="p">};</span>

<span class="cp">#define NDIRECT 12
#define NINDIRECT (BSIZE / sizeof(uint))
#define MAXFILE (NDIRECT + NINDIRECT)
</span>
<span class="c1">// 磁盘上inode节点体现形式</span>
<span class="c1">// On-disk inode structure</span>
<span class="k">struct</span> <span class="n">dinode</span> <span class="p">{</span>
  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>           <span class="c1">// File type</span>
  <span class="kt">short</span> <span class="n">major</span><span class="p">;</span>          <span class="c1">// Major device number (T_DEV only)</span>
  <span class="kt">short</span> <span class="n">minor</span><span class="p">;</span>          <span class="c1">// Minor device number (T_DEV only)</span>
  <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span>          <span class="c1">// Number of links to inode in file system</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>            <span class="c1">// Size of file (bytes)</span>
  <span class="n">uint</span> <span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>   <span class="c1">// Data block addresses</span>
<span class="p">};</span>

<span class="c1">// Inodes per block.</span>
<span class="cp">#define IPB           (BSIZE / sizeof(struct dinode))
</span>
<span class="c1">// Block containing inode i</span>
<span class="cp">#define IBLOCK(i)     ((i) / IPB + 2)
</span>
<span class="c1">// Bitmap bits per block</span>
<span class="cp">#define BPB           (BSIZE*8)
</span>
<span class="c1">// Block containing bit for block b</span>
<span class="cp">#define BBLOCK(b, ninodes) (b/BPB + (ninodes)/IPB + 3)
</span>
<span class="c1">// Directory is a file containing a sequence of dirent structures.</span>
<span class="cp">#define DIRSIZ 14
</span>
<span class="c1">// 文件或目录据结构，目录本身是以文件的方式存储到磁盘上的，叫做目录文件。</span>
<span class="k">struct</span> <span class="n">dirent</span> <span class="p">{</span>
  <span class="n">ushort</span> <span class="n">inum</span><span class="p">;</span> <span class="c1">// i节点</span>
  <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">DIRSIZ</span><span class="p">];</span> <span class="c1">// 文件或目录名</span>
<span class="p">};</span>
</code></pre></div></div> <p>5.file.h：声明inode、file数据结构。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
  <span class="c1">// 分为管道文件,设备文件,普通文件</span>
  <span class="k">enum</span> <span class="p">{</span> <span class="n">FD_NONE</span><span class="p">,</span> <span class="n">FD_PIPE</span><span class="p">,</span> <span class="n">FD_INODE</span> <span class="p">}</span> <span class="n">type</span><span class="p">;</span> 
  <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span> <span class="c1">// reference count</span>
  <span class="kt">char</span> <span class="n">readable</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">writable</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pipe</span> <span class="o">*</span><span class="n">pipe</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ip</span><span class="p">;</span> <span class="c1">// 指向inode节点</span>
  <span class="n">uint</span> <span class="n">off</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 在内存中inode节点体现形式</span>
<span class="c1">// in-memory copy of an inode</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
  <span class="n">uint</span> <span class="n">dev</span><span class="p">;</span>           <span class="c1">// Device number</span>
  <span class="n">uint</span> <span class="n">inum</span><span class="p">;</span>          <span class="c1">// Inode number</span>
  <span class="kt">int</span> <span class="n">ref</span><span class="p">;</span>            <span class="c1">// Reference count</span>
  <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>          <span class="c1">// I_BUSY, I_VALID</span>

	  <span class="c1">// 下面这些编程都是dinode的拷贝</span>
	  <span class="c1">// copy of disk inode</span>
  <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>         
  <span class="kt">short</span> <span class="n">major</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">minor</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">nlink</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">size</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">addrs</span><span class="p">[</span><span class="n">NDIRECT</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>
<span class="cp">#define I_BUSY 0x1
#define I_VALID 0x2
</span>
<span class="c1">// table mapping major device number to device functions</span>
<span class="k">struct</span> <span class="n">devsw</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span><span class="o">*</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)(</span><span class="k">struct</span> <span class="n">inode</span><span class="o">*</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">devsw</span> <span class="n">devsw</span><span class="p">[];</span>

<span class="cp">#define CONSOLE 1
</span></code></pre></div></div> <p>6.ide.c：磁盘IO的具体实现，xv6维护了一个进程请求磁盘操作的队列(idequeue)。当进程调用<strong>void iderw(struct buf *b)</strong>请求读写磁盘时，该请求被加入等待队列idequeue，同时进程进入睡眠状态。当一个磁盘读写操作完成时，会触发一个中断，中断处理程序ideintr()会移除队列开头的请求，唤醒队列开头请求所对应的进程。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// idequeue points to the buf now being read/written to the disk.</span>
<span class="c1">// idequeue-&gt;qnext points to the next buf to be processed.</span>
<span class="c1">// You must hold idelock while manipulating queue.</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">spinlock</span> <span class="n">idelock</span><span class="p">;</span> <span class="c1">// 保护 idequeue</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">idequeue</span><span class="p">;</span> <span class="c1">// 磁盘读写操作的请求队列</span>
<span class="err">……</span>
<span class="c1">// 等待磁盘进入空闲状态</span>
<span class="c1">// Wait for IDE disk to become ready.</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">idewait</span><span class="p">(</span><span class="kt">int</span> <span class="n">checkerr</span><span class="p">)</span>
<span class="p">{</span>
  <span class="err">……</span>
  <span class="c1">// </span>
  <span class="k">while</span><span class="p">(((</span><span class="n">r</span> <span class="o">=</span> <span class="n">inb</span><span class="p">(</span><span class="mh">0x1f7</span><span class="p">))</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">IDE_BSY</span><span class="o">|</span><span class="n">IDE_DRDY</span><span class="p">))</span> <span class="o">!=</span> <span class="n">IDE_DRDY</span><span class="p">);</span>
  <span class="err">……</span>
<span class="p">}</span>

<span class="c1">// 初始化IDE磁盘IO</span>
<span class="kt">void</span> <span class="nf">ideinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="err">……</span>
<span class="p">}</span>

<span class="c1">// 开始一个磁盘读写请求</span>
<span class="c1">// Start the request for b.  Caller must hold idelock.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">idestart</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="err">……</span>
<span class="p">}</span>

<span class="c1">// 当磁盘请求完成后中断处理程序会调用的函数</span>
<span class="c1">// Interrupt handler.</span>
<span class="kt">void</span> <span class="nf">ideintr</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="err">……</span> <span class="c1">// 处理完一个磁盘IO请求后，唤醒等待在等待队列头的那个进程</span>
  <span class="n">wakeup</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  
  <span class="c1">// 如果队列不为空，继续处理下一个磁盘IO任务</span>
  <span class="c1">// Start disk on next buf in queue.</span>
  <span class="k">if</span><span class="p">(</span><span class="n">idequeue</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">idestart</span><span class="p">(</span><span class="n">idequeue</span><span class="p">);</span>
  <span class="err">……</span>
<span class="p">}</span>

<span class="c1">//PAGEBREAK!  上层文件系统调用的磁盘IO接口</span>
<span class="c1">// Sync buf with disk. </span>
<span class="c1">// If B_DIRTY is set, write buf to disk, clear B_DIRTY, set B_VALID.</span>
<span class="c1">// Else if B_VALID is not set, read buf from disk, set B_VALID.</span>
<span class="kt">void</span> <span class="nf">iderw</span><span class="p">(</span><span class="k">struct</span> <span class="n">buf</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="err">……</span> <span class="c1">// 竞争锁</span>
  <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idelock</span><span class="p">);</span>  <span class="c1">//DOC:acquire-lock</span>

  <span class="c1">// Append b to idequeue.</span>
  <span class="n">b</span><span class="o">-&gt;</span><span class="n">qnext</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">pp</span><span class="o">=&amp;</span><span class="n">idequeue</span><span class="p">;</span> <span class="o">*</span><span class="n">pp</span><span class="p">;</span> <span class="n">pp</span><span class="o">=&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">qnext</span><span class="p">)</span>  <span class="c1">//DOC:insert-queue</span>
    <span class="p">;</span>
  <span class="o">*</span><span class="n">pp</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  
  <span class="c1">// Start disk if necessary.  开始处理一个磁盘IO任务</span>
  <span class="k">if</span><span class="p">(</span><span class="n">idequeue</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">idestart</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
  
  <span class="c1">// Wait for request to finish.  睡眠等待</span>
  <span class="k">while</span><span class="p">((</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">B_VALID</span><span class="o">|</span><span class="n">B_DIRTY</span><span class="p">))</span> <span class="o">!=</span> <span class="n">B_VALID</span><span class="p">){</span>
    <span class="n">sleep</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idelock</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">idelock</span><span class="p">);</span>  <span class="c1">// 释放锁</span>
<span class="p">}</span>
</code></pre></div></div> <p>7.bio.c：Buffer Cache的具体实现。因为读写磁盘操作效率不高，根据时间与空间局部性原理，这里将最近经常访问的磁盘块缓存在内存中。主要接口有struct buf* bread(uint dev, uint sector)、void bwrite(struct buf *b)，bread会首先从缓存中去寻找块是否存在，如果存在直接返回，如果不存在则请求磁盘读操作，读到缓存中后再返回结果。bwrite直接将缓存中的数据写入磁盘。 8.log.c：该模块主要是维护文件系统的一致性。引入log模块后，对于上层文件系统的全部磁盘操作都被切分为transaction，每个transaction都会首先将数据和其对应磁盘号写入磁盘上的log区域，且只有在log区域写入成功后，才将log区域的数据写入真正存储的数据块。因此，如果在写log的时候宕机，重启后文件系统视为该log区的写入不存在，如果从log区写到真实区域的时候宕机，则可根据log区域的数据恢复。 9.sysfile.c：主要定义了与文件相关的系统调用。主要接口及含义如下：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// Allocate a file descriptor <span class="k">for </span>the given file.
// Takes over file reference from <span class="nb">caller </span>on success.
static int fdalloc<span class="o">(</span>struct file <span class="k">*</span>f<span class="o">)</span>
<span class="o">{</span>
  …… // 申请一个未使用的文件句柄
<span class="o">}</span>

int sys_dup<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 调用filedup对文件句柄的引用计数+1
  filedup<span class="o">(</span>f<span class="o">)</span><span class="p">;</span>
  <span class="k">return </span>fd<span class="p">;</span>
<span class="o">}</span>

int sys_read<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 读取文件数据
  <span class="k">return </span>fileread<span class="o">(</span>f, p, n<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

int sys_write<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 向文件写数据
  <span class="k">return </span>filewrite<span class="o">(</span>f, p, n<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

int sys_close<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 释放文件句柄资源
  fileclose<span class="o">(</span>f<span class="o">)</span><span class="p">;</span>
  <span class="k">return </span>0<span class="p">;</span>
<span class="o">}</span>

int sys_fstat<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 修改文件统计信息
  <span class="k">return </span>filestat<span class="o">(</span>f, st<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>

// Create the path new as a <span class="nb">link </span>to the same inode as old.
int sys_link<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 为已有的inode创建一个新名字
<span class="o">}</span>

//PAGEBREAK!
int sys_unlink<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 解除inode中的某个名字, 若名字全被移除, inode回被释放
<span class="o">}</span>

static struct inode<span class="k">*</span> create<span class="o">(</span>char <span class="k">*</span>path, short <span class="nb">type</span>, 
	    short major, short minor<span class="o">)</span>
<span class="o">{</span>
  …… // 
<span class="o">}</span>

int sys_mkdir<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 创建一个目录
<span class="o">}</span>

int sys_mknod<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 创建一个新文件
<span class="o">}</span>

int sys_chdir<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 切换目录
<span class="o">}</span>

int sys_pipe<span class="o">(</span>void<span class="o">)</span>
<span class="o">{</span>
  …… // 创建一个管道文件
<span class="o">}</span>
</code></pre></div></div> <p>10.exec.c：只有一个exec接口，实质就是传入elf格式的可执行文件，装载到内存并分配内存页，argv是一个指针数组，用于携带参数。</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">exec</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="err">……</span> <span class="c1">// 判断文件是否存在</span>
  <span class="k">if</span><span class="p">((</span><span class="n">ip</span> <span class="o">=</span> <span class="n">namei</span><span class="p">(</span><span class="n">path</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">ilock</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">pgdir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Check ELF header  检查elf头是否合法</span>
  <span class="k">if</span><span class="p">(</span><span class="n">readi</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">elf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf</span><span class="p">))</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf</span><span class="p">))</span>
    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
  <span class="err">……</span>
  
  <span class="c1">// Load program into memory.</span>
  <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span><span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">off</span><span class="o">=</span><span class="n">elf</span><span class="p">.</span><span class="n">phoff</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">elf</span><span class="p">.</span><span class="n">phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">off</span><span class="o">+=</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ph</span><span class="p">)){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">readi</span><span class="p">(</span><span class="n">ip</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ph</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ph</span><span class="p">))</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ph</span><span class="p">))</span>
      <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ph</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ELF_PROG_LOAD</span><span class="p">)</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">ph</span><span class="p">.</span><span class="n">memsz</span> <span class="o">&lt;</span> <span class="n">ph</span><span class="p">.</span><span class="n">filesz</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
    <span class="k">if</span><span class="p">((</span><span class="n">sz</span> <span class="o">=</span> <span class="n">allocuvm</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">ph</span><span class="p">.</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">ph</span><span class="p">.</span><span class="n">memsz</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">loaduvm</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">ph</span><span class="p">.</span><span class="n">vaddr</span><span class="p">,</span> <span class="n">ip</span><span class="p">,</span> <span class="n">ph</span><span class="p">.</span><span class="n">off</span><span class="p">,</span> <span class="n">ph</span><span class="p">.</span><span class="n">filesz</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Allocate two pages at the next page boundary.</span>
  <span class="c1">// Make the first inaccessible.  Use the second as the user stack.</span>
  <span class="n">sz</span> <span class="o">=</span> <span class="n">PGROUNDUP</span><span class="p">(</span><span class="n">sz</span><span class="p">);</span>
  <span class="k">if</span><span class="p">((</span><span class="n">sz</span> <span class="o">=</span> <span class="n">allocuvm</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">sz</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">PGSIZE</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
  <span class="n">clearpteu</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">sz</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">PGSIZE</span><span class="p">));</span>
  <span class="n">sp</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>

  <span class="c1">// Push argument strings, prepare rest of stack in ustack.</span>
  <span class="k">for</span><span class="p">(</span><span class="n">argc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">];</span> <span class="n">argc</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">argc</span> <span class="o">&gt;=</span> <span class="n">MAXARG</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">sp</span> <span class="o">-</span> <span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">&amp;</span> <span class="o">~</span><span class="mi">3</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">copyout</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">],</span> <span class="n">strlen</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>
    <span class="n">ustack</span><span class="p">[</span><span class="mi">3</span><span class="o">+</span><span class="n">argc</span><span class="p">]</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="err">……</span>

 <span class="nl">bad:</span>
  <span class="k">if</span><span class="p">(</span><span class="n">pgdir</span><span class="p">)</span>
    <span class="n">freevm</span><span class="p">(</span><span class="n">pgdir</span><span class="p">);</span>
  <span class="k">if</span><span class="p">(</span><span class="n">ip</span><span class="p">)</span>
    <span class="n">iunlockput</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> </div> </article> <br> <hr> <br> If you found this useful, please cite this as: <blockquote> <p>Yan, Jing (Aug 2021). xv6 文件系统手册和代码阅读笔记. https://yankaqiu.github.io.</p> </blockquote> <p>or as a BibTeX entry:</p> <div class="language-bibtex highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">@article</span><span class="p">{</span><span class="nl">yan2021xv6-文件系统手册和代码阅读笔记</span><span class="p">,</span>
  <span class="na">title</span>   <span class="p">=</span> <span class="s">{xv6 文件系统手册和代码阅读笔记}</span><span class="p">,</span>
  <span class="na">author</span>  <span class="p">=</span> <span class="s">{Yan, Jing}</span><span class="p">,</span>
  <span class="na">year</span>    <span class="p">=</span> <span class="s">{2021}</span><span class="p">,</span>
  <span class="na">month</span>   <span class="p">=</span> <span class="s">{Aug}</span><span class="p">,</span>
  <span class="na">url</span>     <span class="p">=</span> <span class="s">{https://yankaqiu.github.io/blog/2021/xv6-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/}</span>
<span class="p">}</span>
</code></pre></div></div> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/If-Life-Only-Matters-with-Luck/">If Life Only Matters With Luck</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/The-Ethical-Basis-of-Privacy-Protection/">The Ethical Basis of Privacy Protection</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/%E8%BF%90%E5%8A%A8%E7%BB%99%E6%88%91%E5%B8%A6%E6%9D%A5%E4%BA%86%E4%BB%80%E4%B9%88/">What has sports brought me</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2020/typograms/">小菜鸡的网页学习记录</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Jing Yan. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?70d799092f862ad98c7876aa47712e20"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>